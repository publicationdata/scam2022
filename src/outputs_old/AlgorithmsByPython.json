{"type":{"0":"C","1":"C","2":"C","3":"C","4":"C","5":"C","6":"C","7":"R","8":"W","9":"W","10":"W","11":"C","12":"C","13":"C","14":"C","15":"R","16":"C","17":"C","18":"C","19":"C","20":"C","21":"C","22":"R","23":"C","24":"C","25":"R","26":"W","27":"W","28":"R","29":"C","30":"R","31":"R","32":"R","33":"R"},"module":{"0":"AVL","1":"AVL","2":"AVL","3":"AnagramDetection","4":"AnagramDetection","5":"BinaryTree","6":"BinaryTree","7":"Dynamic Programming","8":"Hash","9":"Hash","10":"Hash","11":"Hash","12":"Hash","13":"Hash","14":"Hash","15":"Hash","16":"Hash","17":"Lists","18":"Lists","19":"Lists","20":"Lists","21":"ParseTree","22":"ParseTree","23":"ParseTree","24":"RadixSort","25":"RadixSort","26":"SelectionSort","27":"Stack","28":"divideAndConquer","29":"heapSort","30":"heapSort","31":"mysingleton","32":"mysingleton","33":"mysingleton"},"obj":{"0":"BinarySearchTree.updateBalance","1":"BinarySearchTree.rotateLeft","2":"BinarySearchTree.rotateRight","3":"AnagramDetection.anagramSolution2","4":"AnagramDetection.anagramSolution2","5":"BinaryTree.insertLeft","6":"BinaryTree.insertRight","7":"maxBag","8":"hash","9":"hash","10":"hash2","11":"hash2","12":"HashTable.put","13":"HashTable.put","14":"HashTable.put","15":"HashTable.put","16":"HashTable.get","17":"UnorderedList.isEmpty","18":"UnorderedList.size","19":"UnorderedList.search","20":"UnorderedList.remove","21":"postorder","22":"postordereval","23":"inorder","24":"radixSortLSD","25":"radixSortLSD","26":"selectionSort","27":"matches","28":"maxIndex","29":"heapSort","30":"heapSort","31":"","32":"","33":""},"lnum":{"0":83,"1":95,"2":113,"3":30,"4":34,"5":8,"6":16,"7":29,"8":6,"9":7,"10":17,"11":18,"12":35,"13":47,"14":50,"15":32,"16":69,"17":29,"18":39,"19":47,"20":65,"21":52,"22":58,"23":72,"24":25,"25":8,"26":4,"27":75,"28":5,"29":2,"30":1,"31":1,"32":1,"33":1},"col":{"0":11,"1":11,"2":11,"3":8,"4":8,"5":11,"6":11,"7":0,"8":0,"9":4,"10":4,"11":4,"12":11,"13":22,"14":19,"15":4,"16":14,"17":15,"18":14,"19":14,"20":11,"21":7,"22":0,"23":7,"24":8,"25":0,"26":8,"27":12,"28":0,"29":7,"30":0,"31":0,"32":0,"33":0},"filename":{"0":"AVL.py","1":"AVL.py","2":"AVL.py","3":"AnagramDetection.py","4":"AnagramDetection.py","5":"BinaryTree.py","6":"BinaryTree.py","7":"Dynamic Programming.py","8":"Hash.py","9":"Hash.py","10":"Hash.py","11":"Hash.py","12":"Hash.py","13":"Hash.py","14":"Hash.py","15":"Hash.py","16":"Hash.py","17":"Lists.py","18":"Lists.py","19":"Lists.py","20":"Lists.py","21":"ParseTree.py","22":"ParseTree.py","23":"ParseTree.py","24":"RadixSort.py","25":"RadixSort.py","26":"SelectionSort.py","27":"Stack.py","28":"divideAndConquer.py","29":"heapSort.py","30":"heapSort.py","31":"mysingleton.py","32":"mysingleton.py","33":"mysingleton.py"},"symbol":{"0":"singleton-comparison","1":"singleton-comparison","2":"singleton-comparison","3":"consider-using-enumerate","4":"consider-using-enumerate","5":"singleton-comparison","6":"singleton-comparison","7":"inconsistent-return-statements","8":"redefined-builtin","9":"redefined-builtin","10":"redefined-builtin","11":"consider-using-enumerate","12":"singleton-comparison","13":"singleton-comparison","14":"singleton-comparison","15":"inconsistent-return-statements","16":"singleton-comparison","17":"singleton-comparison","18":"singleton-comparison","19":"singleton-comparison","20":"singleton-comparison","21":"singleton-comparison","22":"inconsistent-return-statements","23":"singleton-comparison","24":"consider-using-enumerate","25":"inconsistent-return-statements","26":"redefined-builtin","27":"redefined-builtin","28":"inconsistent-return-statements","29":"singleton-comparison","30":"inconsistent-return-statements","31":"duplicate-code","32":"duplicate-code","33":"duplicate-code"},"text":{"0":"Comparison 'node.parent != None' should be 'node.parent is not None'","1":"Comparison 'newRoot.leftChild != None' should be 'newRoot.leftChild is not None'","2":"Comparison 'newRoot.rightChild != None' should be 'newRoot.rightChild is not None'","3":"Consider using enumerate instead of iterating with range and len","4":"Consider using enumerate instead of iterating with range and len","5":"Comparison 'self.leftChild == None' should be 'self.leftChild is None'","6":"Comparison 'self.rightChild == None' should be 'self.rightChild is None'","7":"Either all return statements in a function should return an expression, or none of them should.","8":"Redefining built-in 'hash'","9":"Redefining built-in 'sum'","10":"Redefining built-in 'sum'","11":"Consider using enumerate instead of iterating with range and len","12":"Comparison 'self.slots[hashvalue] == None' should be 'self.slots[hashvalue] is None'","13":"Comparison 'self.slots[nextslot] != None' should be 'self.slots[nextslot] is not None'","14":"Comparison 'self.slots[nextslot] == None' should be 'self.slots[nextslot] is None'","15":"Either all return statements in a function should return an expression, or none of them should.","16":"Comparison 'self.slots[position] != None' should be 'self.slots[position] is not None'","17":"Comparison 'self.head == None' should be 'self.head is None'","18":"Comparison 'current != None' should be 'current is not None'","19":"Comparison 'current != None' should be 'current is not None'","20":"Comparison 'previous == None' should be 'previous is None'","21":"Comparison 'tree != None' should be 'tree is not None'","22":"Either all return statements in a function should return an expression, or none of them should.","23":"Comparison 'tree != None' should be 'tree is not None'","24":"Consider using enumerate instead of iterating with range and len","25":"Either all return statements in a function should return an expression, or none of them should.","26":"Redefining built-in 'min'","27":"Redefining built-in 'open'","28":"Either all return statements in a function should return an expression, or none of them should.","29":"Comparison 'alist == None' should be 'alist is None'","30":"Either all return statements in a function should return an expression, or none of them should.","31":"Similar lines in 2 files\n==AVL:141\n==BinarySearchTree:76\n    def __setitem__(self, k, v):\n        self.put(k, v)\n\n    def get(self, key):\n        if self.root:\n            res = self._get(key, self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n\n    def _get(self, key, currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key, currentNode.leftChild)\n        else:\n            return self._get(key, currentNode.rightChild)\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __contains__(self, key):\n        if self._get(key, self.root):\n            return True\n        else:\n            return False\n\n    def delete(self, key):\n        if self.size > 1:\n            nodeToRemove = self._get(key, self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size -= 1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self, key):\n        self.delete(key)\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def remove(self, currentNode):\n        if currentNode.isLeaf():  # leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren():  # interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n\n        else:  # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                                currentNode.leftChild.payload,\n                                                currentNode.leftChild.leftChild,\n                                                currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                                currentNode.rightChild.payload,\n                                                currentNode.rightChild.leftChild,\n                                                currentNode.rightChild.rightChild)\n\n\n\nmytree = BinarySearchTree()\nmytree[3]=\"red\"\nmytree[4]=\"blue\"\nmytree[6]=\"yellow\"\nmytree[2]=\"at\"\n\nprint(mytree[6])\nprint(mytree[2])","32":"Similar lines in 2 files\n==AVL:1\n==BinarySearchTree:1\nclass TreeNode:\n    def __init__(self, key, val, left = None, right = None, parent = None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent= parent\n\n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n\n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n\n    def replaceNodeData(self, key, value, lc, rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n        self.size = 0\n\n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n\n    def put(self, key, val):\n        if self.root:\n            self._put(key, val, self.root)\n        else:\n            self.root = TreeNode(key, val)\n        self.size = self.size + 1\n\n    def _put(self, key, val, currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key, val, currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key, val, parent=currentNode)","33":"Similar lines in 2 files\n==AVL:71\n==BinarySearchTree:70\n        else:\n            if currentNode.hasRightChild():\n                self._put(key, val, currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key, val, parent=currentNode)"},"number":{"0":"C0121","1":"C0121","2":"C0121","3":"C0200","4":"C0200","5":"C0121","6":"C0121","7":"R1710","8":"W0622","9":"W0622","10":"W0622","11":"C0200","12":"C0121","13":"C0121","14":"C0121","15":"R1710","16":"C0121","17":"C0121","18":"C0121","19":"C0121","20":"C0121","21":"C0121","22":"R1710","23":"C0121","24":"C0200","25":"R1710","26":"W0622","27":"W0622","28":"R1710","29":"C0121","30":"R1710","31":"R0801","32":"R0801","33":"R0801"},"linter":{"0":"pylint","1":"pylint","2":"pylint","3":"pylint","4":"pylint","5":"pylint","6":"pylint","7":"pylint","8":"pylint","9":"pylint","10":"pylint","11":"pylint","12":"pylint","13":"pylint","14":"pylint","15":"pylint","16":"pylint","17":"pylint","18":"pylint","19":"pylint","20":"pylint","21":"pylint","22":"pylint","23":"pylint","24":"pylint","25":"pylint","26":"pylint","27":"pylint","28":"pylint","29":"pylint","30":"pylint","31":"pylint","32":"pylint","33":"pylint"},"lines_amount":{"0":278,"1":278,"2":278,"3":73,"4":73,"5":59,"6":59,"7":45,"8":104,"9":104,"10":104,"11":104,"12":104,"13":104,"14":104,"15":104,"16":104,"17":79,"18":79,"19":79,"20":79,"21":96,"22":96,"23":96,"24":34,"25":34,"26":12,"27":151,"28":30,"29":27,"30":27,"31":5,"32":5,"33":5},"commit":{"0":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","1":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","2":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","3":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","4":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","5":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","6":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","7":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","8":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","9":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","10":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","11":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","12":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","13":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","14":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","15":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","16":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","17":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","18":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","19":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","20":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","21":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","22":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","23":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","24":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","25":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","26":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","27":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","28":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","29":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","30":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","31":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","32":"78d7ac4d93db9da40601a5567350bfb3e97e7d46","33":"78d7ac4d93db9da40601a5567350bfb3e97e7d46"},"repo":{"0":"Jack-Lee-Hiter\/AlgorithmsByPython","1":"Jack-Lee-Hiter\/AlgorithmsByPython","2":"Jack-Lee-Hiter\/AlgorithmsByPython","3":"Jack-Lee-Hiter\/AlgorithmsByPython","4":"Jack-Lee-Hiter\/AlgorithmsByPython","5":"Jack-Lee-Hiter\/AlgorithmsByPython","6":"Jack-Lee-Hiter\/AlgorithmsByPython","7":"Jack-Lee-Hiter\/AlgorithmsByPython","8":"Jack-Lee-Hiter\/AlgorithmsByPython","9":"Jack-Lee-Hiter\/AlgorithmsByPython","10":"Jack-Lee-Hiter\/AlgorithmsByPython","11":"Jack-Lee-Hiter\/AlgorithmsByPython","12":"Jack-Lee-Hiter\/AlgorithmsByPython","13":"Jack-Lee-Hiter\/AlgorithmsByPython","14":"Jack-Lee-Hiter\/AlgorithmsByPython","15":"Jack-Lee-Hiter\/AlgorithmsByPython","16":"Jack-Lee-Hiter\/AlgorithmsByPython","17":"Jack-Lee-Hiter\/AlgorithmsByPython","18":"Jack-Lee-Hiter\/AlgorithmsByPython","19":"Jack-Lee-Hiter\/AlgorithmsByPython","20":"Jack-Lee-Hiter\/AlgorithmsByPython","21":"Jack-Lee-Hiter\/AlgorithmsByPython","22":"Jack-Lee-Hiter\/AlgorithmsByPython","23":"Jack-Lee-Hiter\/AlgorithmsByPython","24":"Jack-Lee-Hiter\/AlgorithmsByPython","25":"Jack-Lee-Hiter\/AlgorithmsByPython","26":"Jack-Lee-Hiter\/AlgorithmsByPython","27":"Jack-Lee-Hiter\/AlgorithmsByPython","28":"Jack-Lee-Hiter\/AlgorithmsByPython","29":"Jack-Lee-Hiter\/AlgorithmsByPython","30":"Jack-Lee-Hiter\/AlgorithmsByPython","31":"Jack-Lee-Hiter\/AlgorithmsByPython","32":"Jack-Lee-Hiter\/AlgorithmsByPython","33":"Jack-Lee-Hiter\/AlgorithmsByPython"}}