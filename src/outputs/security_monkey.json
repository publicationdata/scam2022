{"type":{"0":"R","1":"R","2":"R","3":"R","4":"R","5":"R","6":"R","7":"R","8":"R","9":"C","10":"C","11":"R","12":"R","13":"R","14":"R","15":"R","16":"R","17":"R","18":"R","19":"R","20":"R","21":"R","22":"C","23":"C","24":"R","25":"R","26":"R","27":"R","28":"R","29":"R","30":"R","31":"R","32":"R","33":"R","34":"R","35":"R","36":"R","37":"R","38":"R"},"module":{"0":"manage","1":"manage","2":"manage","3":"manage","4":"manage","5":"manage","6":"manage","7":"manage","8":"manage","9":"manage","10":"manage","11":"manage","12":"manage","13":"manage_api","14":"manage_api","15":"manage_api","16":"manage_api","17":"manage_api","18":"manage_api","19":"manage_api","20":"manage_api","21":"manage_api","22":"manage_api","23":"manage_api","24":"manage_api","25":"manage_api","26":"setup","27":"setup","28":"setup","29":"setup","30":"setup","31":"setup","32":"setup","33":"setup","34":"setup","35":"setup","36":"setup","37":"setup","38":"setup"},"obj":{"0":"run_change_reporter","1":"find_changes","2":"audit_changes","3":"delete_unjustified_issues","4":"backup_config_to_json","5":"amazon_accounts","6":"disable_accounts","7":"enable_accounts","8":"add_override_scores","9":"_parse_accounts","10":"fetch_aws_canonical_ids","11":"sync_networks","12":"AddAccount.__call__","13":"run_change_reporter","14":"find_changes","15":"audit_changes","16":"delete_unjustified_issues","17":"backup_config_to_json","18":"amazon_accounts","19":"disable_accounts","20":"enable_accounts","21":"add_override_scores","22":"_parse_accounts","23":"fetch_aws_canonical_ids","24":"sync_networks","25":"AddAccount.handle","26":"","27":"","28":"","29":"","30":"","31":"","32":"","33":"","34":"","35":"","36":"","37":"","38":""},"lnum":{"0":69,"1":82,"2":98,"3":112,"4":151,"5":190,"6":326,"7":338,"8":448,"9":575,"10":638,"11":792,"12":839,"13":69,"14":82,"15":98,"16":112,"17":151,"18":190,"19":326,"20":338,"21":448,"22":575,"23":638,"24":792,"25":839,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1},"col":{"0":0,"1":0,"2":0,"3":0,"4":0,"5":21,"6":0,"7":0,"8":14,"9":40,"10":36,"11":17,"12":4,"13":0,"14":0,"15":0,"16":0,"17":0,"18":21,"19":0,"20":0,"21":14,"22":40,"23":36,"24":17,"25":4,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0},"filename":{"0":"manage.py","1":"manage.py","2":"manage.py","3":"manage.py","4":"manage.py","5":"manage.py","6":"manage.py","7":"manage.py","8":"manage.py","9":"manage.py","10":"manage.py","11":"manage.py","12":"manage.py","13":"manage_api.py","14":"manage_api.py","15":"manage_api.py","16":"manage_api.py","17":"manage_api.py","18":"manage_api.py","19":"manage_api.py","20":"manage_api.py","21":"manage_api.py","22":"manage_api.py","23":"manage_api.py","24":"manage_api.py","25":"manage_api.py","26":"setup.py","27":"setup.py","28":"setup.py","29":"setup.py","30":"setup.py","31":"setup.py","32":"setup.py","33":"setup.py","34":"setup.py","35":"setup.py","36":"setup.py","37":"setup.py","38":"setup.py"},"symbol":{"0":"inconsistent-return-statements","1":"inconsistent-return-statements","2":"inconsistent-return-statements","3":"inconsistent-return-statements","4":"inconsistent-return-statements","5":"consider-using-with","6":"inconsistent-return-statements","7":"inconsistent-return-statements","8":"consider-using-with","9":"singleton-comparison","10":"singleton-comparison","11":"consider-using-with","12":"inconsistent-return-statements","13":"inconsistent-return-statements","14":"inconsistent-return-statements","15":"inconsistent-return-statements","16":"inconsistent-return-statements","17":"inconsistent-return-statements","18":"consider-using-with","19":"inconsistent-return-statements","20":"inconsistent-return-statements","21":"consider-using-with","22":"singleton-comparison","23":"singleton-comparison","24":"consider-using-with","25":"inconsistent-return-statements","26":"duplicate-code","27":"duplicate-code","28":"duplicate-code","29":"duplicate-code","30":"duplicate-code","31":"duplicate-code","32":"duplicate-code","33":"duplicate-code","34":"duplicate-code","35":"duplicate-code","36":"duplicate-code","37":"duplicate-code","38":"duplicate-code"},"text":{"0":"Either all return statements in a function should return an expression, or none of them should.","1":"Either all return statements in a function should return an expression, or none of them should.","2":"Either all return statements in a function should return an expression, or none of them should.","3":"Either all return statements in a function should return an expression, or none of them should.","4":"Either all return statements in a function should return an expression, or none of them should.","5":"Consider using 'with' for resource-allocating operations","6":"Either all return statements in a function should return an expression, or none of them should.","7":"Either all return statements in a function should return an expression, or none of them should.","8":"Consider using 'with' for resource-allocating operations","9":"Comparison 'Account.third_party == False' should be 'Account.third_party is False' if checking for the singleton value False, or 'not Account.third_party' if testing for falsiness","10":"Comparison 'Account.active == True' should be 'Account.active is True' if checking for the singleton value True, or 'bool(Account.active)' if testing for truthiness","11":"Consider using 'with' for resource-allocating operations","12":"Either all return statements in a function should return an expression, or none of them should.","13":"Either all return statements in a function should return an expression, or none of them should.","14":"Either all return statements in a function should return an expression, or none of them should.","15":"Either all return statements in a function should return an expression, or none of them should.","16":"Either all return statements in a function should return an expression, or none of them should.","17":"Either all return statements in a function should return an expression, or none of them should.","18":"Consider using 'with' for resource-allocating operations","19":"Either all return statements in a function should return an expression, or none of them should.","20":"Either all return statements in a function should return an expression, or none of them should.","21":"Consider using 'with' for resource-allocating operations","22":"Comparison 'Account.third_party == False' should be 'Account.third_party is False' if checking for the singleton value False, or 'not Account.third_party' if testing for falsiness","23":"Comparison 'Account.active == True' should be 'Account.active is True' if checking for the singleton value True, or 'bool(Account.active)' if testing for truthiness","24":"Consider using 'with' for resource-allocating operations","25":"Either all return statements in a function should return an expression, or none of them should.","26":"Similar lines in 2 files\n==manage:337\n==manage_api:337\ndef enable_accounts(accounts):\n    \"\"\" Bulk enables one or more accounts \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    bulk_enable_accounts(account_names)\n\n\n@manager.option('-t', '--tech_name', dest='tech_name', type=str, required=True)\n@manager.option('-m', '--method', dest='method', type=str, required=True)\n@manager.option('-a', '--auditor', dest='auditor', type=str, required=True)\n@manager.option('-s', '--score', dest='score', type=int, required=False)\n@manager.option('-b', '--disabled', dest='disabled', type=bool, default=False)\n@manager.option('-p', '--pattern_scores', dest='pattern_scores', type=str, required=False)\ndef add_override_score(tech_name, method, auditor, score, disabled, pattern_scores):\n    \"\"\"\n    Adds an audit disable\/override scores\n    :param tech_name: technology index\n    :param method: the neme of the auditor method to override\n    :param auditor: The class name of the auditor containing the check method\n    :param score: The default override score to assign to the check method issue\n    :param disabled: Flag indicating whether the check method should be run\n    :param pattern_scores: A comma separated list of account field values and scores.\n           This can be used to override the default score based on some field in the account\n           that the check method is running against. The format of each value\/score is:\n           account_type.account_field.account_value=score\n    \"\"\"\n    from security_monkey.datastore import ItemAuditScore\n    from security_monkey.auditor import auditor_registry\n\n    if tech_name not in auditor_registry:\n        sys.stderr.write('Invalid tech name {}.\\n'.format(tech_name))\n        sys.exit(1)\n\n    valid = False\n    auditor_classes = auditor_registry[tech_name]\n    for auditor_class in auditor_classes:\n        if auditor_class.__name__ == auditor:\n            valid = True\n            break\n    if not valid:\n        sys.stderr.write('Invalid auditor {}.\\n'.format(auditor))\n        sys.exit(1)\n\n    if not getattr(auditor_class, method, None):\n        sys.stderr.write('Invalid method {}.\\n'.format(method))\n        sys.exit(1)\n\n    if score is None and not disabled:\n        sys.stderr.write('Either score (-s) or disabled (-b) required')\n        sys.exit(1)\n\n    if score is None:\n        score = 0\n\n    query = ItemAuditScore.query.filter(ItemAuditScore.technology == tech_name)\n    method_str = \"{method} ({auditor})\".format(method=method, auditor=auditor)\n    query = query.filter(ItemAuditScore.method == method_str)\n    entry = query.first()\n\n    if not entry:\n        entry = ItemAuditScore()\n        entry.technology = tech_name\n        entry.method = method_str\n\n    entry.score = score\n    entry.disabled = disabled\n\n    if pattern_scores is not None:\n        scores = pattern_scores.split(',')\n        for score in scores:\n            left_right = score.split('=')\n            if len(left_right) != 2:\n                sys.stderr.write('pattern_scores (-p) format account_type.account_field.account_value=score\\n')\n                sys.exit(1)\n\n            account_info = left_right[0].split('.')\n            if len(account_info) != 3:\n                sys.stderr.write('pattern_scores (-p) format account_type.account_field.account_value=score\\n')\n                sys.exit(1)\n\n            from security_monkey.account_manager import account_registry\n            if account_info[0] not in account_registry:\n                sys.stderr.write('Invalid account type {}\\n'.format(account_info[0]))\n                sys.exit(1)\n\n            entry.add_or_update_pattern_score(account_info[0], account_info[1], account_info[2], int(left_right[1]))\n\n    db.session.add(entry)\n    db.session.commit()\n    db.session.close()\n\n\n@manager.option('-f', '--file_name', dest='file_name', type=str, required=True)\n@manager.option('-m', '--mappings', dest='field_mappings', type=str, required=False)\ndef add_override_scores(file_name, field_mappings):\n    \"\"\"\n    Refreshes the audit disable\/override scores from a csv file. Old scores not in\n     the csv will be removed.\n    :param file_name: path to the csv file\n    :param field_mappings: Comma separated list of mappings of known types to csv file\n     headers. Ex. 'tech=Tech Name,score=default score'\n    \"\"\"\n    from security_monkey.datastore import ItemAuditScore, AccountPatternAuditScore\n    from security_monkey.auditor import auditor_registry\n    import csv\n\n    csvfile = open(file_name, 'r')\n    reader = csv.DictReader(csvfile)\n    errors = []\n\n    mappings = {\n        'tech': 'tech',\n        'auditor': 'auditor',\n        'method': 'method',\n        'disabled': 'disabled',\n        'score': 'score',\n        'patterns': {}\n    }\n\n    if field_mappings:\n        mapping_defs = field_mappings.split(',')\n        for mapping_def in mapping_defs:\n            mapping = mapping_def.split('=')\n            if mapping[0] in mappings:\n                mappings[mapping[0]] = mapping[1]\n            else:\n                patterns = mappings['patterns']\n                patterns[mapping[0]] = mapping[1]\n\n    line_num = 0\n    entries = []\n    for row in reader:\n        line_num = line_num + 1\n        tech_name = row[mappings['tech']]\n        auditor = row[mappings['auditor']]\n        method = row[mappings['method']]\n\n        if not tech_name or not auditor or not method:\n            continue\n\n        score = None\n        str_score = row[mappings['score']].decode('ascii', 'ignore').strip('')\n        if str_score != '':\n            if not str_score.isdigit():\n                errors.append('Score {} line {} is not a positive int.'.format(str_score, line_num))\n                continue\n            score = int(str_score)\n\n        if row[mappings['disabled']].lower() == 'true':\n            disabled = True\n        else:\n            disabled = False\n\n        if score is None and not disabled:\n            continue\n\n        if score is None:\n            score = 0\n\n        if tech_name not in auditor_registry:\n            errors.append('Invalid tech name {} line {}.'.format(tech_name, line_num))\n            continue\n\n        valid = False\n        auditor_classes = auditor_registry[tech_name]\n        for auditor_class in auditor_classes:\n            if auditor_class.__name__ == auditor:\n                valid = True\n                break\n\n        if not valid:\n            errors.append('Invalid auditor {} line {}.'.format(auditor, line_num))\n            continue\n\n        if not getattr(auditor_class, method, None):\n            errors.append('Invalid method {} line {}.'.format(method, line_num))\n            continue\n\n        entry = ItemAuditScore(technology=tech_name, method=method + ' (' + auditor + ')',\n                               score=score, disabled=disabled)\n\n        pattern_mappings = mappings['patterns']\n        for mapping in pattern_mappings:\n            str_pattern_score = row[pattern_mappings[mapping]].decode('ascii', 'ignore').strip()\n            if str_pattern_score != '':\n                if not str_pattern_score.isdigit():\n                    errors.append('Pattern score {} line {} is not a positive int.'.format(str_pattern_score, line_num))\n                    continue\n\n                account_info = mapping.split('.')\n                if len(account_info) != 3:\n                    errors.append('Invalid pattern mapping {}.'.format(mapping))\n                    continue\n\n                from security_monkey.account_manager import account_registry\n                if account_info[0] not in account_registry:\n                    errors.append('Invalid account type {}'.format(account_info[0]))\n                    continue\n\n                db_pattern_score = AccountPatternAuditScore(account_type=account_info[0],\n                                                            account_field=account_info[1],\n                                                            account_pattern=account_info[2],\n                                                            score=int(str_pattern_score))\n\n                entry.account_pattern_scores.append(db_pattern_score)\n\n        entries.append(entry)\n\n    if len(errors) > 0:\n        for error in errors:\n            sys.stderr.write(\"{}\\n\".format(error))\n        sys.exit(1)\n\n    AccountPatternAuditScore.query.delete()\n    ItemAuditScore.query.delete()\n\n    for entry in entries:\n        db.session.add(entry)\n\n    db.session.commit()\n    db.session.close()\n\n\ndef _parse_tech_names(tech_str):\n    if tech_str == 'all':","27":"Similar lines in 2 files\n==manage:673\n==manage_api:673\n        if app.config.get('USE_ROUTE53'):\n            route53 = Route53Service()\n            route53.register(app.config.get('FQDN'), exclusive=True)\n\n        workers = kwargs['workers']\n        address = kwargs['address']\n\n        if not GUNICORN:\n            print('GUNICORN not installed. Try `runserver` to use the Flask debug server instead.')\n        else:\n            class FlaskApplication(Application):\n                def init(self, parser, opts, args):\n                    return {\n                        'bind': address,\n                        'workers': workers,\n                        'timeout': 1800\n                    }\n\n                def load(self):\n                    return app\n\n            FlaskApplication().run()\n\n\n@manager.option('-o', '--owner', type=text_type, required=True,\n                help=\"Owner of the accounts, this is often set to a company name.\")\n@manager.option('-b', '--bucket-name', dest='bucket_name', type=text_type, required=True,\n                help=\"S3 bucket where SWAG data is stored.\")\n@manager.option('-p', '--bucket-prefix', dest='bucket_prefix', type=text_type, default='accounts.json',\n                help=\"Prefix to fetch account data from. Default: accounts.json\")\n@manager.option('-r', '--bucket-region', dest='bucket_region', type=text_type, default='us-east-1',\n                help=\"Region SWAG S3 bucket is located. Default: us-east-1\")\n@manager.option('-t', '--account-type', dest='account_type', default='AWS',\n                help=\"Type of account to sync from SWAG data. Default: AWS\")\n@manager.option('-s', '--spinnaker', dest='spinnaker', default=False, action='store_true',\n                help='Use the spinnaker names as account names.')\ndef sync_swag(owner, bucket_name, bucket_prefix, bucket_region, account_type, spinnaker):\n    \"\"\"Use the SWAG client to sync SWAG accounts to Security Monkey.\"\"\"\n    from security_monkey.account_manager import account_registry\n\n    swag_opts = {\n        'swag.type': 's3',\n        'swag.bucket_name': bucket_name,\n        'swag.data_file': bucket_prefix,\n        'swag.region': bucket_region\n    }\n\n    swag = SWAGManager(**parse_swag_config_options(swag_opts))\n    account_manager = account_registry[account_type]()\n\n    for account in swag.get_all(\"[?provider=='{provider}']\".format(provider=account_type.lower())):\n        services = account.get('services', [])\n        services_by_name = {s['name']: s for s in services}\n\n        # Check if the account is active or not:\n        # With the current SWAG schema, need to do the following:\n        # 1. Check if the 'account_status' field is set to 'ready'.\n        # 2. Loop through all the services for \"security_monkey\" and if the status is \"active\", then the account\n        #    is active.\n        check_active = active = False\n        if account['account_status'] == 'ready':\n            check_active = True\n\n        if check_active:\n            secmonkey_service = services_by_name.get('security_monkey', {})\n            for status in secmonkey_service.get('status', []):\n                if status['region'] == 'all':\n                    active = status.get('enabled', False)\n                    break\n\n        thirdparty = account['owner'] != owner\n        if spinnaker:\n            spinnaker_name = swag.get_service_name('spinnaker', \"[?id=='{id}']\".format(id=account['id']))\n            if not spinnaker_name:\n                name = account['name']\n            else:\n                name = spinnaker_name\n        else:\n            name = account['name']\n\n        notes = account['description']\n        identifier = account['id']\n\n        custom_fields = {}\n        s3_name = swag.get_service_name('s3', \"[?id=='{id}']\".format(id=account['id']))\n        if s3_name:\n            custom_fields['s3_name'] = s3_name\n\n        s3_service = services_by_name.get('s3', {})\n        if s3_service:\n            c_id = s3_service['metadata'].get('canonicalId', None)\n            if c_id:\n                custom_fields['canonical_id'] = c_id\n        role_name = secmonkey_service.get('metadata', {}).get('role_name', None)\n        if role_name is not None:\n            custom_fields['role_name'] = role_name\n\n        account_manager.sync(account_manager.account_type, name, active, thirdparty,\n                             notes, identifier,\n                             custom_fields=custom_fields)\n    db.session.close()\n    app.logger.info('SWAG sync successful.')\n\n\n@manager.option('-b', '--bucket-name', dest='bucket_name', type=text_type, help=\"S3 bucket where network whitelist data is stored.\")\n@manager.option('-i', '--input-filename', dest='input_filename', type=text_type, default='networks.json', help=\"File path or bucket prefix to fetch account data from. Default: networks.json\")\n@manager.option('-a', '--authoritative', dest='authoritative', default=False, action='store_true', help='Remove all networks not named in `input_filename`.')\ndef sync_networks(bucket_name, input_filename, authoritative):\n    \"\"\"Imports a JSON file of networks to the Security Monkey whitelist.\"\"\"\n    if bucket_name:\n        import boto3\n        s3 = boto3.client('s3')\n        response = s3.get_object(\n            Bucket=bucket_name,\n            Key=input_filename,\n        )\n        handle = response['Body']\n    else:\n        handle = open(input_filename)\n    networks = json.load(handle)\n    handle.close()\n    existing = NetworkWhitelistEntry.query.filter(\n        NetworkWhitelistEntry.name.in_(networks)\n    )\n    new = set(networks.keys()) - set(entry.name for entry in existing)\n    for entry in existing:\n        entry.cidr = networks[entry.name]\n        db.session.add(entry)\n    for name in new:\n        app.logger.debug('Adding new network %s', name)\n        entry = NetworkWhitelistEntry(\n            name=name,\n            cidr=networks[name],\n        )\n        db.session.add(entry)\n    if authoritative:\n        old = NetworkWhitelistEntry.query.filter(\n            ~NetworkWhitelistEntry.name.in_(networks)\n        )\n        for entry in old:\n            app.logger.debug('Removing stale network %s', entry.name)\n            db.session.delete(entry)\n    db.session.commit()\n    db.session.close()\n\n\nclass AddAccount(Command):\n    def __init__(self, account_manager, *args, **kwargs):\n        super(AddAccount, self).__init__(*args, **kwargs)\n        self._account_manager = account_manager\n        self.__doc__ = \"Add %s account\" % account_manager.account_type\n\n    def get_options(self):\n        options = [\n            Option('-n', '--name', type=text_type, required=True),\n            Option('--id', dest='identifier', type=text_type, required=True),\n            Option('--thirdparty', action='store_true'),\n            Option('--active', action='store_true'),\n            Option('--notes', type=text_type),\n            Option('--update-existing', action=\"store_true\")\n        ]\n        for cf in self._account_manager.custom_field_configs:\n            options.append(Option('--%s' % cf.name, dest=cf.name, type=str))\n        return options\n","28":"Similar lines in 2 files\n==manage:201\n==manage_api:201\n            for aws_account in info['accounts']:\n                acct_name = \"{group} ({region})\".format(group=group, region=aws_account['region'])\n                account = Account.query.filter(Account.identifier == aws_account['account_id']).first()\n                if not account:\n                    app.logger.debug('    Adding account {0}'.format(acct_name))\n                    account = Account()\n                else:\n                    app.logger.debug('    Updating account {0}'.format(acct_name))\n\n                account.identifier = aws_account['account_id']\n                account.account_type_id = account_type_result.id\n                account.active = False\n                account.third_party = True\n                account.name = acct_name\n                account.notes = info['url']\n\n                db.session.add(account)\n\n        db.session.commit()\n        app.logger.info('Finished adding Amazon owned accounts')\n    except Exception as e:\n        app.logger.exception(\"An error occured while adding accounts\")\n        store_exception(\"manager-amazon-accounts\", None, e)\n\n\n@manager.command\n@manager.option('-e', '--email', dest='email', type=text_type, required=True)\n@manager.option('-r', '--role', dest='role', type=str, required=True)\ndef create_user(email, role):\n    from flask_security import SQLAlchemyUserDatastore\n    from security_monkey.datastore import User\n    from security_monkey.datastore import Role\n    from flask_security.utils import encrypt_password\n\n    user_datastore = SQLAlchemyUserDatastore(db, User, Role)\n\n    ROLES = ['View', 'Comment', 'Justify', 'Admin']\n    if role not in ROLES:\n        sys.stderr.write('[!] Role must be one of [{0}].\\n'.format(' '.join(ROLES)))\n        sys.exit(1)\n\n    users = User.query.filter(User.email == email)\n\n    if users.count() == 0:\n        password1 = prompt_pass(\"Password\")\n        password2 = prompt_pass(\"Confirm Password\")\n\n        if password1 != password2:\n            sys.stderr.write(\"[!] Passwords do not match\\n\")\n            sys.exit(1)\n\n        user = user_datastore.create_user(email=email,\n                                          password=encrypt_password(password1),\n                                          confirmed_at=datetime.now())\n    else:\n        sys.stdout.write(\"[+] Updating existing user\\n\")\n        user = users.first()\n\n        password1 = prompt_pass(\"Password\")\n        password2 = prompt_pass(\"Confirm Password\")\n\n        if password1 != password2:\n            sys.stderr.write(\"[!] Passwords do not match\\n\")\n            sys.exit(1)\n\n        user.password = encrypt_password(password1)\n\n    user.role = role\n\n    db.session.add(user)\n    db.session.commit()\n\n\n@manager.option('-e', '--email', dest='email', type=text_type, required=True)\n@manager.option('-a', '--active', dest='active', type=bool, required=False, default=False, help='To disable, you must omit this flag.')\ndef toggle_active_user(email, active):\n    \"\"\"Enables\/Disables a user.\n\n    To enable a user, provide the \"--active True\" flag value. To disable it, omit the --active flag. Do not use \"--active False\",\n    or it will set the value to True.\n    \"\"\"\n    from security_monkey.datastore import User\n\n    users = User.query.filter(User.email == email)\n\n    if users.count() == 0:\n        sys.stderr.write(\"[!] User is not found.\\n\")\n        sys.exit(1)\n\n    else:\n        sys.stdout.write(\"[+] Setting active toggle for user {} to {}\\n\".format(email, active))\n        user = users.first()\n\n        user.active = active\n\n        db.session.add(user)\n        db.session.commit()\n\n        sys.stdout.write(\"[+] Done!\\n\")\n\n\n# Commented out because this will cause issues with linked issues and justifications.\n# @manager.command\n# @manager.option('-e', '--email', dest='email', type=text_type, required=True)\n# def delete_user(email):\n#     from security_monkey.datastore import User\n#\n#     users = User.query.filter(User.email == email)\n#\n#     if users.count() == 0:\n#         sys.stderr.write(\"[!] User is not found.\\n\")\n#         sys.exit(1)\n#\n#     else:\n#         sys.stdout.write(\"[-] Deleting user {}\\n\".format(email))\n#         user = users.first()\n#\n#         db.session.delete(user)\n#         db.session.commit()\n#\n#         sys.stdout.write(\"[+] Done!\\n\")\n\n","29":"Similar lines in 2 files\n==manage:567\n==manage_api:567\n    else:\n        return tech_str.split(',')\n\n\ndef _parse_accounts(account_str, active=True):\n    \"\"\"Parse the account ID or name. This will raise a KeyError if it can't find it.\"\"\"\n    if account_str == 'all':\n        accounts = Account.query.filter(Account.third_party == False).filter(Account.active == active).all()\n        accounts = [account.name for account in accounts]\n        return accounts\n    else:\n        names_or_ids = account_str.split(',')\n        accounts = Account.query.all()\n        accounts_by_id = {account.identifier: account.name for account in accounts}\n        accounts_by_name = {account.name: account.identifier for account in accounts}\n\n        # Verify that the account name exists (raise a KeyError if it doesn't):\n        names = []\n        for n in names_or_ids:\n            if not accounts_by_id.get(n):\n                _ = accounts_by_name[n]\n\n            names.append(n)\n\n        return names\n\n\n@manager.option('-n', '--name', dest='name', type=text_type, required=True)\ndef delete_account(name):\n    from security_monkey.account_manager import delete_account_by_name\n    delete_account_by_name(name)\n\n\n@manager.option('-t', '--tech_name', dest='tech_name', type=str, required=True)\n@manager.option('-d', '--disabled', dest='disabled', type=bool, default=False)\n# We are locking down the allowed intervals here to 15 minutes, 1 hour, 12 hours, 24\n# hours or one week because too many different intervals could result in too many\n# scheduler threads, impacting performance.\n@manager.option('-i', '--interval', dest='interval', type=int, default=60, choices=[15, 60, 720, 1440, 10080])\ndef add_watcher_config(tech_name, disabled, interval):\n    from security_monkey.datastore import WatcherConfig\n    from security_monkey.watcher import watcher_registry\n\n    if tech_name not in watcher_registry:\n        sys.stderr.write('Invalid tech name {}.\\n'.format(tech_name))\n        sys.exit(1)\n\n    query = WatcherConfig.query.filter(WatcherConfig.index == tech_name)\n    entry = query.first()\n\n    if not entry:\n        entry = WatcherConfig()\n\n    entry.index = tech_name\n    entry.interval = interval\n    entry.active = not disabled\n\n    db.session.add(entry)\n    db.session.commit()\n    db.session.close()\n\n\n@manager.option(\"--override\", dest=\"override\", type=bool, default=True)\ndef fetch_aws_canonical_ids(override):\n    \"\"\"\n    Adds S3 canonical IDs in for all AWS accounts in SM.\n    \"\"\"\n    app.logger.info(\"[ ] Fetching S3 canonical IDs for all AWS accounts being monitored by Security Monkey.\")\n\n    # Get all the active AWS accounts:\n    accounts = Account.query.filter(Account.active == True) \\\n        .join(AccountType).filter(AccountType.name == \"AWS\").all()  # noqa\n\n    get_canonical_ids(accounts, override=override)\n\n    app.logger.info(\"[@] Completed canonical ID fetching.\")\n\n\n@manager.command\ndef clean_stale_issues():\n    \"\"\"\n    Cleans up issues for auditors that have been removed\n    \"\"\"\n    from security_monkey.common.audit_issue_cleanup import clean_stale_issues\n    clean_stale_issues()\n\n\nclass APIServer(Command):\n    def __init__(self, host='127.0.0.1', port=app.config.get('API_PORT'), workers=12):\n        self.address = \"{}:{}\".format(host, port)\n        self.workers = workers\n\n    def get_options(self):\n        return (\n            Option('-b', '--bind',\n                   dest='address',\n                   type=str,\n                   default=self.address),\n            Option('-w', '--workers',\n                   dest='workers',\n                   type=int,\n                   default=self.workers),\n        )\n","30":"Similar lines in 2 files\n==manage:13\n==manage_api:13\nfrom datetime import datetime\nimport json\nimport sys\n\nfrom flask_script import Manager, Command, Option, prompt_pass\n\nfrom six import text_type\n\nfrom security_monkey.account_manager import bulk_disable_accounts, bulk_enable_accounts\nfrom security_monkey.common.s3_canonical import get_canonical_ids\nfrom security_monkey.datastore import clear_old_exceptions, store_exception, AccountType, ItemAudit, NetworkWhitelistEntry\n\nfrom security_monkey import app, db, jirasync\nfrom security_monkey.common.route53 import Route53Service\n\nfrom flask_migrate import Migrate, MigrateCommand\n\nfrom security_monkey.task_scheduler.tasks import manual_run_change_reporter, manual_run_change_finder\nfrom security_monkey.task_scheduler.tasks import audit_changes as sm_audit_changes\nfrom security_monkey.backup import backup_config_to_json as sm_backup_config_to_json\nfrom security_monkey.common.utils import find_modules, load_plugins\nfrom security_monkey.datastore import Account\nfrom security_monkey.watcher import watcher_registry\n\nfrom swag_client.backend import SWAGManager\nfrom swag_client.util import parse_swag_config_options\n\ntry:\n    from gunicorn.app.base import Application\n\n    GUNICORN = True\nexcept ImportError:\n    # Gunicorn does not yet support Windows.\n    # See issue #524. https:\/\/github.com\/benoitc\/gunicorn\/issues\/524\n    # For dev on Windows, make this an optional import.\n    print('Could not import gunicorn, skipping.')\n    GUNICORN = False\n\nmanager = Manager(app)\nmigrate = Migrate(app, db)\nmanager.add_command('db', MigrateCommand)\n\nfind_modules('alerters')\nfind_modules('watchers')\nfind_modules('auditors')\nload_plugins('security_monkey.plugins')\n\n\n@manager.command\ndef drop_db():\n    \"\"\" Drops the database. \"\"\"\n    db.drop_all()\n\n","31":"Similar lines in 2 files\n==manage:150\n==manage_api:150\ndef backup_config_to_json(accounts, monitors, outputfolder):\n    \"\"\" Saves the most current item revisions to a json file. \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    sm_backup_config_to_json(account_names, monitor_names, outputfolder)\n\n\n@manager.command\ndef sync_jira():\n    \"\"\" Syncs issues with Jira \"\"\"\n    if jirasync:\n        app.logger.info('Syncing issues with Jira')\n        jirasync.sync_issues()\n    else:\n        app.logger.info('Jira sync not configured. Is SECURITY_MONKEY_JIRA_SYNC set?')\n\n\n@manager.command\ndef clear_expired_exceptions():\n    \"\"\"\n    Clears out the exception logs table of all exception entries that have expired past the TTL.\n    :return:\n    \"\"\"\n    app.logger.info(\"Clearing out exceptions that have an expired TTL...\")\n    clear_old_exceptions()\n    app.logger.info(\"Completed clearing out exceptions that have an expired TTL.\")\n\n\n@manager.command\ndef amazon_accounts():\n    \"\"\" Pre-populates standard AWS owned accounts \"\"\"\n    import json\n    from security_monkey.datastore import Account, AccountType\n\n    data = json.load(open(\"data\/aws_accounts.json\", 'r'))\n\n    app.logger.info('Adding \/ updating Amazon owned accounts')\n    try:\n        account_type_result = AccountType.query.filter(AccountType.name == 'AWS').first()\n        if not account_type_result:\n            account_type_result = AccountType(name='AWS')\n            db.session.add(account_type_result)\n            db.session.commit()\n            db.session.refresh(account_type_result)\n","32":"Similar lines in 2 files\n==manage:111\n==manage_api:111\ndef delete_unjustified_issues(accounts, monitors):\n    \"\"\" Allows us to delete unjustified issues. \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    issues = ItemAudit.query.filter_by(justified=False).all()\n    for issue in issues:\n        del issue.sub_items[:]\n        db.session.delete(issue)\n    db.session.commit()\n\n\n@manager.option('-o', '--output-file', dest='output_file', type=text_type, default='environment_summary.json')\ndef export_environment_summary(output_file):\n    \"\"\" Save the Auditor.OBJECT_STORE as a JSON file. \"\"\"\n    from security_monkey.auditor import Auditor\n    from collections import defaultdict\n\n    # Build the Environment Summary\n    Auditor._load_object_store()\n\n    # Convert sets to lists so we can serialize with JSON\n    json_safe_object = defaultdict(dict)","33":"Similar lines in 2 files\n==manage:843\n==manage_api:843\n        identifier = kwargs.pop('identifier')\n        update = kwargs.pop('update_existing', False)\n        if update:\n            result = self._account_manager.update(None, self._account_manager.account_type, name, active, thirdparty,\n                                                  notes, identifier,\n                                                  custom_fields=kwargs\n                                                  )\n        else:\n            result = self._account_manager.create(\n                self._account_manager.account_type,\n                name, active, thirdparty, notes, identifier,\n                custom_fields=kwargs)\n        db.session.close()\n\n        if not result:\n            return -1\n\n\ndef main():\n    from security_monkey.account_manager import account_registry\n","34":"Similar lines in 2 files\n==manage:95\n==manage_api:95\n@manager.option('-r', '--send_report', dest='send_report', type=bool, default=False)\n@manager.option('-s', '--skip_batch', dest='skip_batch', type=bool, default=False)\ndef audit_changes(accounts, monitors, send_report, skip_batch):\n    \"\"\" Runs auditors \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    sm_audit_changes(account_names, monitor_names, send_report, skip_batch=skip_batch)\n\n","35":"Similar lines in 2 files\n==manage:81\n==manage_api:81\ndef find_changes(accounts, monitors):\n    \"\"\" Runs watchers \"\"\"\n    monitor_names = _parse_tech_names(monitors)\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    manual_run_change_finder(account_names, monitor_names)\n\n","36":"Similar lines in 2 files\n==manage:325\n==manage_api:325\ndef disable_accounts(accounts):\n    \"\"\" Bulk disables one or more accounts \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    bulk_disable_accounts(account_names)\n\n","37":"Similar lines in 2 files\n==manage:68\n==manage_api:68\ndef run_change_reporter(accounts):\n    \"\"\" Runs Reporter \"\"\"\n    try:\n        account_names = _parse_accounts(accounts)\n    except KeyError as e:\n        app.logger.error(\"The passed in account: {} does not exist in Security Monkey's database.\".format(e.message))\n        return -1\n\n    manual_run_change_reporter(account_names)\n\n","38":"Similar lines in 2 files\n==manage:865\n==manage_api:865\n        manager.add_command(\"add_account_%s\" % name.lower(), AddAccount(account_manager()))\n    manager.add_command(\"run_api_server\", APIServer())\n    manager.run()\n\n\nif __name__ == \"__main__\":\n    main()"},"number":{"0":"R1710","1":"R1710","2":"R1710","3":"R1710","4":"R1710","5":"R1732","6":"R1710","7":"R1710","8":"R1732","9":"C0121","10":"C0121","11":"R1732","12":"R1710","13":"R1710","14":"R1710","15":"R1710","16":"R1710","17":"R1710","18":"R1732","19":"R1710","20":"R1710","21":"R1732","22":"C0121","23":"C0121","24":"R1732","25":"R1710","26":"R0801","27":"R0801","28":"R0801","29":"R0801","30":"R0801","31":"R0801","32":"R0801","33":"R0801","34":"R0801","35":"R0801","36":"R0801","37":"R0801","38":"R0801"},"linter":{"0":"pylint","1":"pylint","2":"pylint","3":"pylint","4":"pylint","5":"pylint","6":"pylint","7":"pylint","8":"pylint","9":"pylint","10":"pylint","11":"pylint","12":"pylint","13":"pylint","14":"pylint","15":"pylint","16":"pylint","17":"pylint","18":"pylint","19":"pylint","20":"pylint","21":"pylint","22":"pylint","23":"pylint","24":"pylint","25":"pylint","26":"pylint","27":"pylint","28":"pylint","29":"pylint","30":"pylint","31":"pylint","32":"pylint","33":"pylint","34":"pylint","35":"pylint","36":"pylint","37":"pylint","38":"pylint"},"lines_amount":{"0":894,"1":894,"2":894,"3":894,"4":894,"5":894,"6":894,"7":894,"8":894,"9":894,"10":894,"11":894,"12":894,"13":873,"14":873,"15":873,"16":873,"17":873,"18":873,"19":873,"20":873,"21":873,"22":873,"23":873,"24":873,"25":873,"26":72,"27":72,"28":72,"29":72,"30":72,"31":72,"32":72,"33":72,"34":72,"35":72,"36":72,"37":72,"38":72},"commit":{"0":"c28592ffd518fa399527d26262683fc860c30eef","1":"c28592ffd518fa399527d26262683fc860c30eef","2":"c28592ffd518fa399527d26262683fc860c30eef","3":"c28592ffd518fa399527d26262683fc860c30eef","4":"c28592ffd518fa399527d26262683fc860c30eef","5":"c28592ffd518fa399527d26262683fc860c30eef","6":"c28592ffd518fa399527d26262683fc860c30eef","7":"c28592ffd518fa399527d26262683fc860c30eef","8":"c28592ffd518fa399527d26262683fc860c30eef","9":"c28592ffd518fa399527d26262683fc860c30eef","10":"c28592ffd518fa399527d26262683fc860c30eef","11":"c28592ffd518fa399527d26262683fc860c30eef","12":"c28592ffd518fa399527d26262683fc860c30eef","13":"c28592ffd518fa399527d26262683fc860c30eef","14":"c28592ffd518fa399527d26262683fc860c30eef","15":"c28592ffd518fa399527d26262683fc860c30eef","16":"c28592ffd518fa399527d26262683fc860c30eef","17":"c28592ffd518fa399527d26262683fc860c30eef","18":"c28592ffd518fa399527d26262683fc860c30eef","19":"c28592ffd518fa399527d26262683fc860c30eef","20":"c28592ffd518fa399527d26262683fc860c30eef","21":"c28592ffd518fa399527d26262683fc860c30eef","22":"c28592ffd518fa399527d26262683fc860c30eef","23":"c28592ffd518fa399527d26262683fc860c30eef","24":"c28592ffd518fa399527d26262683fc860c30eef","25":"c28592ffd518fa399527d26262683fc860c30eef","26":"c28592ffd518fa399527d26262683fc860c30eef","27":"c28592ffd518fa399527d26262683fc860c30eef","28":"c28592ffd518fa399527d26262683fc860c30eef","29":"c28592ffd518fa399527d26262683fc860c30eef","30":"c28592ffd518fa399527d26262683fc860c30eef","31":"c28592ffd518fa399527d26262683fc860c30eef","32":"c28592ffd518fa399527d26262683fc860c30eef","33":"c28592ffd518fa399527d26262683fc860c30eef","34":"c28592ffd518fa399527d26262683fc860c30eef","35":"c28592ffd518fa399527d26262683fc860c30eef","36":"c28592ffd518fa399527d26262683fc860c30eef","37":"c28592ffd518fa399527d26262683fc860c30eef","38":"c28592ffd518fa399527d26262683fc860c30eef"},"repo":{"0":"Netflix\/security_monkey","1":"Netflix\/security_monkey","2":"Netflix\/security_monkey","3":"Netflix\/security_monkey","4":"Netflix\/security_monkey","5":"Netflix\/security_monkey","6":"Netflix\/security_monkey","7":"Netflix\/security_monkey","8":"Netflix\/security_monkey","9":"Netflix\/security_monkey","10":"Netflix\/security_monkey","11":"Netflix\/security_monkey","12":"Netflix\/security_monkey","13":"Netflix\/security_monkey","14":"Netflix\/security_monkey","15":"Netflix\/security_monkey","16":"Netflix\/security_monkey","17":"Netflix\/security_monkey","18":"Netflix\/security_monkey","19":"Netflix\/security_monkey","20":"Netflix\/security_monkey","21":"Netflix\/security_monkey","22":"Netflix\/security_monkey","23":"Netflix\/security_monkey","24":"Netflix\/security_monkey","25":"Netflix\/security_monkey","26":"Netflix\/security_monkey","27":"Netflix\/security_monkey","28":"Netflix\/security_monkey","29":"Netflix\/security_monkey","30":"Netflix\/security_monkey","31":"Netflix\/security_monkey","32":"Netflix\/security_monkey","33":"Netflix\/security_monkey","34":"Netflix\/security_monkey","35":"Netflix\/security_monkey","36":"Netflix\/security_monkey","37":"Netflix\/security_monkey","38":"Netflix\/security_monkey"},"stargazers":{"0":4232,"1":4232,"2":4232,"3":4232,"4":4232,"5":4232,"6":4232,"7":4232,"8":4232,"9":4232,"10":4232,"11":4232,"12":4232,"13":4232,"14":4232,"15":4232,"16":4232,"17":4232,"18":4232,"19":4232,"20":4232,"21":4232,"22":4232,"23":4232,"24":4232,"25":4232,"26":4232,"27":4232,"28":4232,"29":4232,"30":4232,"31":4232,"32":4232,"33":4232,"34":4232,"35":4232,"36":4232,"37":4232,"38":4232}}